---
title: 'SG1022 Seminar 2: Composite Indicators'
author: "Christopher Gandrud"
date: "2016"
output:
  ioslides_presentation:
    css: https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css
    logo: https://raw.githubusercontent.com/christophergandrud/Hertie_Collab_Data_Science/master/img/HertieCollaborativeDataLogo_v1.png
  beamer_presentation: default
  slidy_presentation: default
---

## <i class="fa fa-arrow-circle-o-up"></i> Objectives

- Getting (local) data into R

- Getting data into R from the World Bank Development Indicators with `WDI`

- Dealing with missing data

- Correlation--statistics and plots

- Rescaling

- Weighting and Aggregating

## <i class="fa fa-check"></i> Pop Quiz

- What is the **difference** between R and RStudio?

- In R, what are **packages** and how do you **install** and load them?

- What are **objects** and what are **functions**? Give examples.

- What is the **assignment operator**? What is **component selection**?

## <i class="fa fa-bolt"></i> Importance of understanding files/file structures

- This topic may seem kind of . . . dry.

- Why not just click and drag files with the GUI (Graphical User Interface)?

## <i class="fa fa-bolt"></i> Importance of understanding files/file structures

- **Reproducibility**: other researchers only have your files. If they are **well
    organised** and the **links** between the files are **explicitly stated**
    then they can better understand what you did.

    + Clearest way of explicitly stating links is **dynamically** using file
    paths in your source code.

- **You**: well organised files will be easier for you to find/understand/use
    in the future.


## <i class="fa fa-folder-open-o"></i> File paths

- Files are organised **hierarchically** into (upside down) trees.

```{r eval=FALSE}
Root
|_
    Parent
    |_
        Child1
        Child2
```

## <i class="fa fa-folder-open-o"></i> Root

**Root** directories are the **first level of a disk**.

They are the root out of which the file tree grows.

**Naming Conventions**:

**Linux/Mac**: `/`

- e.g. `/git_repos` means that the `git_repos` directory is a child
of the root directory.

**Windows**: the disk is partitioned, e.g. the `C` partition is denoted `C:\`.

- `C:\git_repos` indicates that the `git_repos` directory is a child
of the `C` partition.

## <i class="fa fa-folder-open-o"></i> Sub (child) directories

Sub (child) directories are denoted with a `/` in Linux/Mac and `\` in Windows, e.g.:

```{r engine='sh', eval=FALSE}
# Linux/Mac
/git_repos/Project1

# Windows
C:\git_repos\Project1
```

<i class="fa fa-exclamation"></i> R tip:

- In R for Windows you either use two backslashes `\\` (`\` is the R [escape
character](http://en.wikipedia.org/wiki/Escape_character))

- Or `/` in **relative paths** in R for Windows, it will know
what you mean.

## <i class="fa fa-folder-open-o"></i> Working directories

A **working directory** is the directory where the program looks for files/other
directories.

<i class="fa fa-exclamation"></i> **Always remember the working directory.**

- Otherwise you may open/save files that you do not want to open/save.

## <i class="fa fa-folder-open-o"></i> Working directories

**In R:**

```{r}
# Find working directory
getwd()

# List all files in the working directory
list.files()
```

```{r, eval=FALSE}
# Set root as working directory
setwd('/')
```

## <i class="fa fa-folder-open-o"></i> Relative vs. Absolute file paths

Use **relative file paths** when possible.

- **Absolute file path**: the entire path on a particular system,
    + E.g. `/git_repos/Project1/data.csv`

- **Relative file path**: the path relative to the working directory.

    + E.g. if `/git_repos` is the working directory then the relative path for
    `data.csv` is `Project1/data.csv`.

Why?

- Your scripts will run easily on **other computers**. **Enhances reproducibility**.
Easier for your collaborators. Easier for you when you use another computer.

## <i class="fa fa-folder-open-o"></i> File & directory name conventions

<i class="fa fa-exclamation-triangle"></i> **Don't use spaces** in your file names.

They can create problems for programs that treat spaces as an indication that the
path has ended.

Alternatives:

- `CamelCase` (ex. `DataAnalysis.R`)

- `file_underscore` (ex. `data_analysis.R`)

## Loading data into R

R can load data from many different file formats (e.g. .sav (SPSS), .xlsx (Excel), .dta (Stata), .csv).

The [rio](https://github.com/leeper/rio) (R input/output) package makes it very easy to import many different types of data.

It has two key functions `import` and `export`.

## Rio `import` for loading data into R

```{r, warning=FALSE}
library(rio)
setwd('/git_repositories/city_sg1022/seminars/week_2/data/')

# Load DPI 2012 data in Stata format
dpi <- import('dpi2012.dta')

head(dpi[1:3, 1:6])
```

# Note: Always look at the data you imported to see if it's what you think you imported/see what needs cleaning.

## Rio `export` for saving data

We can save the `dpi` data into another format. For example, .csv "Comma Separated Values". Just add the csv file extension to the file name and rio does the rest.

```{r, eval=FALSE}
export(dpi, 'dpi2012.csv')
```

## World Development Indicators

You can also load data stored remotely (on another computer) into R. There are many ways to do this, depending on the data source.

Today we will download data from the World Bank's [World Development Indicators](http://data.worldbank.org/indicator) using the [WDI](https://github.com/vincentarelbundock/WDI) package.

## Find WDI Indicator ID

-  **Go** the the World Bank's website: <http://data.worldbank.org/indicator>.

- **Click** on the indicator you are interested in.

- **Copy** the indicator ID. Example for *Foreign Direct Investment*:

![indicator_id](img/wdi_indicator_id.png)

## Download WDI

Now use the `WDI` function to download the indicator:

```{r message=FALSE, cache=TRUE}
# Load WDI package
library(WDI)

# Download data. Place in new object called fdi
fdi <- WDI(indicator = 'BX.KLT.DINV.CD.WD', start = 1990, end = 2014)

head(fdi)
```

## Some cleaning

We probably want to do some cleaning of this data set:

- Rename the indicator to something that is more intuitive.

- Remove units that are not countries (e.g. 'Arab World')

## Renaming variables

To rename variables in a data frame use the `rename` function from the [dplyr](https://github.com/hadley/dplyr) package.

```{r, message=FALSE}
library(dplyr)

fdi <- rename(fdi, foreign_direct_investment = BX.KLT.DINV.CD.WD)

head(fdi)
```

## Removing non-countries (1)

All countries have an [ISO 2 Letter Country Code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). These include 2 letters.

`iso2c` codes have patterns that we can use to select specific types of units.

- Regions (like 'Arab World') have `iso2c` codes that begin or end with a number.

- Economic groupings (Euroarea, Heavily indebted poor countries, etc) have `iso2c` letter codes beginning with X and Z (XC, XE, etc).

- Finally, we want to drop the EU (EU) and OECD (OE) in order to not double count units. . .

## Removing non-countries (3)

```{r}
# Create vector of all iso2c codes for units we don't want
regions <- unique(fdi$iso2c[grep('[0-9]', fdi$iso2c)])
regions <- c(regions, fdi$iso2c[grep('^[XZ]', fdi$iso2c)])
regions <- c(regions, 'EU', 'OE')

# Keep rows with iso2c codes that do not begin with a number
fdi <- subset(fdi, !(iso2c %in% regions))

head(fdi)
```

## <i class="fa fa-arrow-up"></i> Advanced: Regex

If you are interested: we use [regular expressions](https://en.wikipedia.org/wiki/Regular_expression) to select character strings with certain characteristics (e.g. `[0-9]`, `[^[XZ]]`).

Note: regular expressions are very powerful, but also can take awhile to learn.

## Download multiple WDI indicators

We can download multiple indicators at once. To do this simply create a **vector of ID code strings**:

```{r, cache=TRUE}
indicators <- c('EN.ATM.METH.KT.CE', 'EG.USE.ELEC.KH.PC',
                         'EN.ATM.CO2E.PC', 'SP.POP.GROW',
                         'EG.USE.COMM.CL.ZS')

wdi <- WDI(indicator = indicators, start = 1990, end = 2014)

names(wdi)
```

## Missing Data

Remember that in R, missing data is usually coded `NA`. Note that sometimes data set creators also use other codes, such as `-999`.

A good first step for exploring missing data is to use the `summary` function, which gives you a count of the number of NA's. It will also help you identify if there are any `-999` codes, i.e. likely by showing unintuitive `min` and `max` values.

```{r}
summary(fdi$foreign_direct_investment)
```

## Look at the data

Always take a look at your data to get a sense of the distribution of missing values. Maybe spot why values are missing.

![missing-look](img/look_at_missing.png)

## Recode special values to NA

Special codes like `-999` often indicate specific reasons for missing data. You should take the time to **understand the substantive meaning** of these codes.

Ultimately, you may want to convert these into `NA` for analysis.

For example, imagine we have a data frame called `survey` and we want to recode all `-999` values of some variable called `trust` as `NA`

```{r eval=FALSE}
data$trust[data$trust == -999] <- NA
```

## Dropping observations with missing data (1)

You can drop observations with missing values on **one** variable with `subset`:

```{r, eval=FALSE}
fdi <- subset(fdi, is.na(foreign_direct_investment))
```

## Dropping observations with missing data (2)

You can drob missing data on **multiple variables** with the `DropNA` function from the [DataCombine](https://github.com/christophergandrud/DataCombine) package.

```{r}
library(DataCombine)

# Remember we created the vector of indicator names earlier
wdi <- DropNA(wdi, Var = indicators)
```

Use this to get **complete cases** for your composite indicator.

## Single impute missing values

Once you have analysed the reasons for your missing data, it **may** be reasonable to single impute values rather than drop cases.

For example, maybe it is reasonable to replace `NA` values with the variable `mean`:

```{r, eval=FALSE}
fdi$foreign_direct_investment[
                        is.na(fdi$foreign_direct_investment)] <-
                    mean(fdi$foreign_direct_investment, na.rm = TRUE)
```

**Note:** these decisions need to be **fully justified**.

## <i class="fa fa-balance-scale"></i> Rescaling

As we discussed in the lecture, there are multiple ways you can rescale your component variables so that they are all on the same scale, e.g. **Min-Max**, and **Z-Scores**.

Before we learn these specific tools, let's learn a powerful new capability: creating your own functions.

## <i class="fa fa-arrow-up"></i> Creating Functions

Use the `function` function to create new functions!

E.g. we can create a function to find the sample mean
($\bar{x} = \frac{\sum x}{n}$) of a vector.

```{r}
fun_mean <- function(x){
    sum(x) / length(x)
}

## Find the mean
fun_mean(x = swiss$Examination)
```

## <i class="fa fa-arrow-up"></i> Why create functions?

Functions:

- Simplify your code if you do repeated tasks.

- Lead to fewer mistakes.

- Are easier to understand.

- Save time over the long run--a general solution to problems in different
contexts.

## <i class="fa fa-balance-scale"></i> Min-Max function

To create a function to do Min-Max rescaling remember the equation:

$$
I_{u,t} = \frac{x_{u,t} - \mathrm{min}(\mathrm{X})}{\mathrm{max}(\mathrm{X}) - \mathrm{min}(\mathrm{X})}
$$

So the R function would be:

```{r}
min_max <- function(x) {
            (x - min(x, na.rm = T))/
            (max(x, na.rm = T) - min(x, na.rm = T))
}
```

## <i class="fa fa-balance-scale"></i> Min-Max rescale

Now use the function:

```{r}
fdi$fdi_min_max <- min_max(fdi$foreign_direct_investment)

```

## <i class="fa fa-balance-scale"></i> Compare original to Min-Max

```{r include=FALSE}
library(tidyr)

fdi_min <- fdi[, c('iso2c', 'year', 'foreign_direct_investment', 'fdi_min_max')]

fdi_min <- fdi_min %>% gather(version, value, 3:4)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)

ggplot(fdi_min, aes(value, group = version)) +
    geom_histogram() +
    facet_wrap(~ version, scale = 'free') +
    xlab('') + ylab('Count\n') +
    theme_bw()
```

## <i class="fa fa-balance-scale"></i> Z-Score rescale

The equation for Z-Scores is:

$$
I_{u,t} = \frac{x_{u,t} - \mu_{\mathrm{X}}}{\sigma_{\mathrm{X}}}
$$

So, the R function would be:

```{r}
z_score <- function(x) {
                (x - mean(x, na.rm = T)) /
                sd(x, na.rm = T)
}
```

## <i class="fa fa-balance-scale"></i> Z-Score rescale

Now use the function:

```{r}
fdi$fdi_z_score <- z_score(fdi$foreign_direct_investment)
```

## <i class="fa fa-balance-scale"></i> Compare original to Z-Score

```{r include=FALSE}
fdi_z <- fdi[, c('iso2c', 'year', 'foreign_direct_investment', 'fdi_z_score')]

fdi_z <- fdi_z %>% gather(version, value, 3:4)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(fdi_z, aes(value, group = version)) +
    geom_histogram() +
    facet_wrap(~ version, scale = 'free') +
    xlab('') + ylab('Count\n') +
    theme_bw()
```

## <i class="fa fa-undo"></i> Reverse a variable's direction

The equation to reverse a variable's direction:

$$
I_{u,t} = \mathrm{max}(\mathrm{X}) - x_{u,t}
$$

So the function would be:

```{r}
reverse_direction <- function(x) max(x, na.rm = T) - x
```

Now use the function:

```{r}
fdi$fdi_z_reverse <- reverse_direction(fdi$fdi_z_score)
```

## <i class="fa fa-undo"></i> Reverse

```{r include=FALSE}
fdi_rev <- fdi[, c('iso2c', 'year', 'fdi_z_score', 'fdi_z_reverse')]

fdi_rev <- fdi_rev %>% gather(version, value, 3:4)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
ggplot(fdi_rev, aes(value, group = version)) +
    geom_histogram() +
    facet_wrap(~ version, scale = 'free') +
    xlab('') + ylab('Count\n') +
    theme_bw()
```

## <i class="fa fa-plus"></i> Weight/Aggregate

Once we have our rescaled components, we then decide on how to weight and aggregate our indicators.

For this class you will use 'expert-judgement'.

## <i class="fa fa-plus"></i> Weight/Aggregate example

```{r include=FALSE}
regions <- unique(wdi$iso2c[grep('[0-9]', wdi$iso2c)])
regions <- c(regions, wdi$iso2c[grep('^[XZ]', wdi$iso2c)])
regions <- c(regions, 'EU', 'OE')

# Keep rows with iso2c codes that do not begin with a number
wdi <- subset(wdi, !(iso2c %in% regions))

# Rename indicators
wdi <- wdi %>% rename(methane_emissions = EN.ATM.METH.KT.CE) %>%
               rename(electricity_use = EG.USE.ELEC.KH.PC) %>%
               rename(co2_emissions = EN.ATM.CO2E.PC) %>% 
               rename(population_growth = SP.POP.GROW) %>%
               rename(alternative_energy = EG.USE.COMM.CL.ZS)

# Drop incomplete cases
indicators_environ <- c('electricity_use', 'co2_emissions', 
                         'population_growth', 'alternative_energy')
wdi_sub <- DropNA(wdi, indicators_environ)

# Z-Score rescale
for (i in indicators_environ) {
    wdi_sub[, i] <- z_score(wdi_sub[, i])
}

# Reverse the alternative energy use scale
wdi_sub$alternative_energy <- reverse_direction(wdi_sub$alternative_energy)
```

Imagine we have four variables that we want to combine into our environmental unsustainability index: `electricity_use`, `co2_emissions`, `population_growth`, and `alternative_energy`. 

We have use z-scores to rescale them and reversed the direction of `alternative_energy`. The results are in a data frame called `wdi_sub`. 

We think that `co2_emissions` is particularly important so we give it a weighting of 0.3, the others have a weighting of 0.1:

```{r}
wdi_sub$unsustainability <- wdi_sub$co2_emissions * 0.3 + 
                                  wdi_sub$electricity_use * 0.1 +
                                  wdi_sub$population_growth * 0.1 +
                                  wdi_sub$alternative_energy * 0.1
```

## Component indicator results

```{r}
hist(wdi_sub$unsustainability, main = '', 
     xlab = 'Raw Unsustainability Index')
```

## Rescale the index

We could of course rescale the index so that it is between 0 and 100.

```{r}
wdi_sub$unsustainability <- min_max(wdi_sub$unsustainability) * 100
```

## Rescaled index

```{r}
hist(wdi_sub$unsustainability, main = '', 
     xlab = 'Rescaled Unsustainability Index')
```

## <i class="fa fa-map-o"></i> Map the index

You could also map the results (good sanity check):

```{r, message=FALSE}
# Subset data for only 2011
wdi_2011 <- subset(wdi_sub, year == 2011)

# Use the googleVis package to create the map
library(googleVis)

map <- gvisGeoChart(wdi_2011, locationvar = "country", 
                 colorvar = "unsustainability")
```

## <i class="fa fa-map-o"></i> Map the index

```{r eval=FALSE}
plot(map)
```

![index-map](img/unsustainable_map.png)
